---
title: 数据结构——树
date: 2016-11-16 15:45:35
categories: algorithm
tags: tree
---

树相关算法

<!-- more -->
# 介绍

## 二叉树

- 第i层的结点总数不超过2<sup>i-1</sup>
- 深度为h（根结点深度为1）的二叉树最少有h个结点,最多有2<sup>h</sup>-1个结点
- 深度为h（根结点深度为1）的满二叉树有2<sup>h</sup>-1个结点
- 树（所有类型的树）的总结点数 = 总度数 + 1。度可以理解为树中路径或者边的个数，由于在树中除了根结点，其他结点都有唯一一条路径指向它；所以，总度数+1=总结点数。
- 对于任意一颗二叉树,度为0的结点(叶子结点)数为N<sub>0</sub>,度为2的结点的个数为N<sub>2</sub>,则N<sub>0</sub> = N<sub>2</sub> + 1。  

```
证明：
设总度数为k，N0为度为0的结点数，N1为度为1的结点数，N2为度为2的结点数。
易知：总度数 k = 2*N2 + N1
总结点数 k+1 = N2 + N1 + N0，由上面两个方程消掉k和N1：
N2+1 = N0
```
- 具有n个结点的完全二叉树的深度为floor(log<sub>2</sub>n)+1
- 给定n个结点，能构成(2n)!/((n+1)!*n!)种形态的二叉树。（卡特兰数） 
- 完全二叉树度为1的结点最多只有一个
- 完全二叉树结点总数为n，则叶结点的个数为ceiling(n/2)

```
证明：
设结点总数为n，N0为度为0的结点数，N1为度为1的结点数，N2为度为2的结点数。
易知：总结点数 n = N2 + N1 + N0
由上面的证明可知:N0=N2+1，由上面两个方程消掉N2：
N0 = (n-N1+1)/2。
在完全二叉树中N1的取值要么是0要么是1。
所以，如果n为奇数，那么N1=0，N0=(n+1)/2=ceiling(n/2)；
如果n为偶数，那么N1=1，N0=n/2=ceiling(n/2)
综上，叶子结点数N0=ceiling(n/2)
```
- 结点的平衡因子定义为：该结点左子树的高度-该结点右子树的高度。如果树中每个结点的平衡因子的取值在集合{-1, 0, 1}内，该树就是平衡树。
- 路径及其长度——在一棵树中，从一个结点往下可以达到的孩子或者孙子之间的通路，称为路径。通路中分支的数目称为路径长度。如果根结点的层数为1，则根结点到第L层的路径长度为L-1.
- 结点的带权路径长度——如果给树中的结点赋予一个权重，结点的“带权路径长度”为：从根结点到该结点之间的路径长度与该结点权重的乘积。
- 树的带权路径长度——所有叶子结点的带权路径长度之和，即使WPL（Weight Path Length）。
- 最优二叉树/哈夫曼树（Huffman Tree）——带权路径最小的树。（权值较大的结点离根结点近）

### 完全二叉树
Complete Binary Tree:只有最下面的两层结点度能够小于2,并且最下面一层的结点都集中在该层最左边。

### 满二叉树
Full Binary Tree:除最后一层无任何子结点,每一层上的所有结点都有两个子结点。满二叉树是完全二叉树的特例。

### 二叉查找树
二叉查找树（Binary Search Tree），也称二叉搜索树、二叉有序树。二叉查找树的性质如下：  

1. 如果任意结点的左子树不为空，则左子树上所有结点均小于它的根结点的值；
2. 如果任意结点的右子树不为空，则右子树上所有结点均大于它的根结点的值；
3. 任意结点的左、右子树也都是二叉查找树；
4. 没有键值相等的结点。

二叉查找树的优势在于：查找、插入的时间复杂度较低，为O(logn)。  
二叉查找树的中序遍历输出的是递增的序列。

### [Huffman树](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81)
带权路径最小的树。
二叉Huffman树中只有度为0和2的结点,所有如果Huffman树叶子结点右n0个,那么Huffman树总结点数为2*n0-1


### 平衡树
当且仅当两个子树的高度差不超过1时，这个树是平衡二叉树。也叫AVL树
它的左子树和右子树都是平衡二叉树。

### 红黑树
红黑树是一种自平衡二叉查找树。典型的用途是实现关联数组。

### 决策树
决策树又称判定树


### 回归树

### kd树




# Example
## 遍历

1. 树一共有4种遍历方式：前序遍历、中序遍历、后序遍历和层次遍历
2. 由于前序遍历第一个访问的是根结点,所以前序遍历的第一个输出是根结点
3. 由于后序遍历最后一个访问的是根结点,所以后序遍历的最后一个输出是根结点
4. 层次遍历的第一个访问根结点
5. 在中序遍历中,根结点左边的是左子树,右边的是右子树
6. 在树的四种遍历方式中，并不是知道两种遍历结果就可以确定一棵树的结构；但是，如果知道中序遍历和另外一种遍历方式，就可以唯一确定一棵树。

### Ex.1前序遍历
根结点--左子树--右子树

### Ex.2中序遍历
左子树--根结点--右子树

### Ex.3后序遍历
左子树--右子树--根结点

### Ex.4层次遍历




### Ex.5

```
已知某二叉树的前序遍历序列为A,B,E,F,G,C,H,D,I,J;
中序遍历序列为E,F,G,B,H,C,I,J,D,A。
写出该二叉树的后序遍历结果。
```

> **思路:** 根据前序或者后序确定根结点,然后根据中序将树分成左右子树;递归这个过程。

1. 由前序遍历可知,根结点为A。
2. 在中序遍历中,根结点A右边没有内容,可以知道,根结点A只有左子树;把根结点A画出来,然后在前序和中序遍历中删掉根结点,前序变为B,E,F,G,C,H,D,I,J,后序变为E,F,G,B,H,C,I,J,D。
3. 根据步骤2删减后的前序可以知道,根结点为B(也就是根结点A的左孩子是B);观察后序可以知道,E,F,G为B的左子树成员,H,C,I,J,D为B的右子树成员。在A左孩子的位置画出B,然后删掉B;此时前序变为E,F,G,C,H,D,I,J,中序变为E,F,G和H,C,I,J,D两个部分。
4. 观察前序可以知道B的左子树根结点为E,由步骤3中划分的中序可知,E没有左子树;F和G是E的右子树成员。此时可以确定结点E的位置了,然后将其删掉。前序变为F,G,C,H,D,I,J,中序变为F,G和H,C,I,J,D两个部分。
5. 观察前序,可以知道F是E的右孩子;由于G在F的右边,所以G是F的右孩子。
6. 对于结点B的右子树,也可以使用上述过程。

后序遍历的结果是:GFEHJIDCBA

#### EX.6

```
二叉树中序遍历为dbaecf,层次遍历为abcdef,后序遍历为?。
```

根据层次遍历可以知道根结点为a,左子树包含db,右子树包含ecf。由于层次遍历中b在d前面,所以d是b的子结点;由于层次遍历中,c在e前面,所以ef是c的子结点。由于中序遍历中e在的序列是ecf,所以e是c的左孩子,f是c的右孩子。这样就可以画出树的结构如下:

```
    a
  b    c
d     e f
```

所以,后序遍历的结果是dbefca



## 结点及度计算
### Ex.1

```
若满二叉树的结点总数为20-40之间的一个素数，则该二叉树中叶结点的数目为？
```
深度为h（根结点深度为1）的满二叉树结点总数为2<sup>h</sup>-1，叶子结点数目为2<sup>h-1</sup>。满足题目条件的h值为5，所以叶结点数为16.
### Ex.2

```
具有6个结点二叉树一共有多少种？
```
根据公式，(2n)!/((n+1!)*n!)可知，具有6个结点的二叉树有132种。
### Ex.3

```
具有n个结点且深度也为n的二叉树一共有多少种？
```
深度为n的二叉树至少有n个结点，所以这个问题中，每层只有一个结点。这个问题可以简化为每层是左孩子还是右孩子的问题，一共有2<sup>n</sup>中组合
### Ex.4

```
已知某个完全二叉树有767个结点，其叶子结点的个数为？
```
完全二叉树的叶子结点数=ceiling(n/2)=ceiling(767/2)=384

### 旋转
旋转主要用来调整树的局部平衡性，每一次旋转操作不会影响该树中序遍历的结果。




# TODO
卡特兰数问题  



